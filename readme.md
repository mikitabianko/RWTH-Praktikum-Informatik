# Aufgabenblock 1

## Motivation

In diesem ersten Aufgabenblock werden Klassen für die zu simulierenden Fahrzeuge erstellt, PKWs und Fahrräder, die sich selbst fortbewegen können und simulierbar sind. Ein Mini-Eventhandler ruft eine entsprechende Simulationsschrittmethode aller Fahrzeuge mehrmals auf und gibt den aktuellen Stand der Fahrzeuge nach jedem Schritt auf dem Bildschirm aus.

In diesem Aufgabenblock werden folgende Punkte betrachtet:
- Deklaration und Definition von Klassen,
- Implementierung von Konstruktoren und Destruktoren,
- Kapselung von Daten und Zugriﬀ auf private Member,
- Elementare Verwendung von Smartpointern und static Variablen,
- Vererbung,
- Einsatz der STL (string, vector),
- Unterscheidung der Klassenbereiche public, private und protected,
- Unterscheidung einfache und virtuelle Vererbung,
- Überladen von Operatoren.

***Um sich einen Überblick zu verschaffen, lesen Sie den ersten Aufgabenblock zunächst komplett durch.***

## Fahrzeuge (Einfache Klassen)
1. Starten Sie Eclipse und erstellen Sie in Ihrem Homebereich ein neues Projekt mit dem Namen Aufgabenblock_1.
2. Andern Sie den C++-Dialekt Ihres Projektes auf C++-17. Dazu klicken Sie mit der rechten Maustaste auf Ihr Projekt und wählen ”Properties” aus. Hier wählen Sie nun ”C/C + + Build →Settings” aus. Auf der rechten Seite wählen Sie nun den Reiter ”Tool Settings”. Hier öﬀnen Sie nun ”GCC C + + Compiler → Dialect”. Im rechten Bereich wählen Sie nun unter ”Language standard” ”ISO C++ 17 (-std=c++17)”.
3. Implementieren Sie eine Klasse *Fahrzeug* zur Verwaltung verschiedener Fahrzeuge. Die Klasse soll zunächst lediglich private Membervariablen haben, in denen der Name des Fahrzeugs (p_sName) und eine eindeutige ID (p_iID) zu jedem Objekt gespeichert wird. Benutzen Sie für den Namen den Datentyp string. Implementieren Sie einen Konstruktor, der einen string als Parameter hat und damit den Namen initialisiert. Weiterhin soll die Klasse mit einem Default-Konstruktor konstruierbar sein. Dann soll der Name leer (””) sein. Zum Initialisieren der Variablen können Sie diese direkt bei der Definition mit 0 bzw. ”” vorbesetzen. Die ID soll im Konstruktor anhand einer hochzählenden, Klassenvariablen p_iMaxID vergeben werden. Nutzen Sie im Konstruktor eine Initialisierungsliste, um die Konstanten einmalig mit einem Wert zu besetzen. Da sich die ID nach der Konstruktion nicht mehrändert, können Sie diese als constdefinieren. Wie Sie Klassenvariablen definieren, können Sie im Skript (Statische Klassenelemente) nachlesen. 
   Erzeugen Sie in den Konstruktoren und dem Destruktor eine Ausgabe, welche den Namen und die ID des erzeugten bzw. gelöschten Objekts mit einem entsprechenden Hinweis auf die Operation auf der Standardausgabe cout ausgibt. 
   Für das weitere Programm setzen Sie da, wo Sie können, Variablen und Funktionen bevorzugt const.
4. Beim Programmieren ist es meist ratsam, schnell ein laufähiges Programm zu haben. Erzeugen Sie eine neue C++-Datei (main.cpp), die die Funktion vAufgabe_1() aufruft und implementieren Sie diese Funktion innerhalb der Datei main.cpp. Erzeugen Sie in dieser Funktion einige Elemente statisch (über Deklaration) und einige dynamisch (mit new). Löschen Sie zum Schluss die dynamisch erzeugten Elemente. Erzeugen und starten Sie das Programm und testen Sie das korrekte Erzeugen und Löschen der Objekte. Im Anschluss erzeugen Sie nun einige Smartpointer (siehe Skript). Benutzen Sie dazu `make_unique<Fahrzeug>` und `make_shared<Fahrzeug>`, um von beiden Typen je 2 Objekte vom Typ Fahrzeug zu erzeugen. Speichern Sie eines der als shared ptr erzeugten Objekte in einem weiteren shared_ptr. Lassen Sie sich vor und nach der Zuweisung mit use_count die Anzahl der Referenzen ausgeben. Versuchen Sie dasselbe mit unique_ptr. Erzeugen Sie zusätzlich einen `vector<unique_ptr<Fahrzeug>>`. Speichern Sie die oben erzeugten Fahrzeuge in diesem Vektor. Welche Fahrzeuge können Sie dort speichern? Wie müssen Sie den Besitzwechsel anzeigen? Löschen Sie danach den Vektor mit clear. Beobachten Sie mit dem Debugger, was dort passiert und wann die Objekte durch Aufruf des Destruktors gelöscht werden. 
   Erzeugen Sie nun zusätzlich auch einen `vector<shared_ptr<Fahrzeug>>`. Welche Fahrzeuge können Sie dort speichern? Fügen Sie dem Vektor zwei Fahrzeuge hinzu, eins mit und eins ohne move. Lassen Sie die Anzahl der Referenzen ausgeben. Beobachten Sie wieder mit dem Debugger, was dort passiert und wann die Objekte durch Aufruf des Destruktors gelöscht werden. Bitte notieren Sie beim Debuggen, in welchen Zeilen die jeweiligen Objekte gelöscht werden. Machen Sie sich in dieser Aufgabe mit den Grundfunktionen des Debuggers (Schrittmöglichkeiten, Haltepunkte) bekannt. Beobachten Sie im Fenster für die Variablenüberwachung den Inhalt der Variablen. Die Benutzung des Debuggers wird im Skript beschrieben. Die Funktionen des Debuggers müssen bei der Abnahme ggf. vorgeführt und erläutert werden.
5. Erweitern Sie die Klasse um Membervariablen für die Maximalgeschwindigkeit des Fahrzeugs (p_dMaxGeschwindigkeit), die bisher zurückgelegte Gesamtstrecke (p_dGesamtStrecke), die gesamte Fahrzeit des Objektes (p_dGesamtZeit) und die Zeit, zu der das Fahrzeug zuletzt simuliert wurde (p_dZeit). Fügen Sie einen weiteren Konstruktor hinzu, der einen Namen und die maximale Geschwindigkeit als Parameter bekommt. Beachten Sie hier, dass die Geschwindigkeit immer positiv sein soll. Prüfen Sie dies in der Initialisierungsliste mit Hilfe des ?-Operators.
6. Da dieses Programm noch nicht viel am Bildschirm ausgibt, schreiben Sie eine Memberfunktion vAusgeben(). Diese Memberfunktion soll spezifische Fahrzeugdaten ausgeben. Machen Sie innerhalb dieser Funktion keine Aufrufe von cout::endl, sondern programmieren Sie die Zeilenwechsel in der Hauptfunktion. Die Ausgabe soll so formatiert werden, dass unter einer Uberschrift die Daten tabellarisch aufgelistet werden, in etwa folgendermaßen:

| ID  | Name  | MaxGeschwindigkeit | Gesamtstrecke |
| --- | ----- | ------------------ | ------------- |
| 1   | PKW1  | 40.00              | 0.00          |
| 2   | AUTO3 | 30.00              | 0.00          |
	 Die Überschrift soll durch eine Klassenfunktion void vKopf() ausgegeben werden. Benutzen Sie für die Formatierung keine feste Anzahl von Leerzeichen, sondern die Input-Output-Manipulatoren der Standard C++ Bibliothek (`<iomanip>`). Schreiben Sie eine Klassenfunktion in Fahrzeug, um mit Fahrzeug::vKopf() die Überschrift ausgeben zu können. Beachte: Bei Verwendung von setiosflags() zum Setzen der Ausgabeausrichtung (rechts-/linksbündig) sollte zunächst die andere Ausrichtung mittels resetiosflags() zurückgesetzt werden.
7. Bevor die Simulationsfunktion der Fahrzeuge geschrieben werden kann, muss erst noch eine globale Uhr programmiert werden, damit die Fahrzeuge wissen, wie viele Stunden sie simulieren sollen. Zur Realisierung dieser Uhr definieren Sie eine globale Variable dGlobaleZeit, die Sie mit 0.0 initialisieren. 
   **Beachte**: Zur Benutzung dieser Variablen innerhalb anderer Klassen muss sie der Klasse erst mittels der extern-Deklaration bekannt gemacht werden.
8. Schreiben Sie nun die Memberfunktion Fahrzeug::vSimulieren(), welche dafür sorgt, dass die Fahrzeuge sich fortbewegen. Dazu wird mit Hilfe der globalen Uhr ermittelt, wieviel Zeit seit dem letzten Simulationsschritt vergangen ist, und entsprechend dieser Information wird der Zustand des Fahrzeugs aktualisiert (u.a. Gesamtstrecke um die im ermittelten Zeitraum aufgrund der Geschwindigkeit fahrbare Strecke erhöhen). Lassen Sie das Fahrzeug mit maximaler Geschwindigkeit fahren. Sorgen Sie durch einen Zeitvergleich dafür, dass ein Fahrzeug in einem Zeitschritt nur einmal bearbeitet wird, auch wenn es versehentlich zweimal innerhalb eines Zeitschritts aufgerufen wird. Aktualisieren Sie auch die Gesamtfahrzeit und die letzte Abfertigungszeit des Objektes. Momentan sind diese Werte noch gleich. Das wird sich später ändern.
9. Schreiben Sie eine neue Hauptfunktion vAufgabe_1a(). Lesen Sie Namen und Maximalgeschwindigkeit für 3 Fahrzeuge aus der Konsole ein, erzeugen Sie diese mit `make_unique<Fahrzeug>` und speichern sie diese in einem Vektor. Simulieren Sie Fahrzeuge über eine gewisse Zeitspanne. Erhöhen Sie dazu in einer Schleife die globale Uhr jeweils um einen Zeittakt und rufen Sie in der Schleife die Simulationsfunktion und die Ausgabefunktion der Fahrzeuge auf. Wählen Sie als Zeittakt auch Bruchteile von Stunden.
## 4.3 Fahrräder und PKW (Unterklassen)
1. Implementieren Sie zwei neue Klassen PKW und Fahrrad, die jeweils von der Basisklasse Fahrzeug abgeleitet werden. Strukturieren Sie die Klasse Fahrzeug dementsprechend um. Überlegen Sie, welche Variablen private bleiben sollten und welche protected werden. Überlegen Sie weiterhin, welche Funktionen virtual werden. Benutzen sie synchron dazu das Schlüsselwort overridefür diese Funktionen in den abgeleiteten Klassen. Überlegen Sie zusätzlich welche Funktionen und/oder Variablen Sie const setzen können.
2. Da Fahrräder mit Muskelkraft und PKWs mit Motoren betrieben werden, benötigt die Klasse PKW zusätzliche PKW-spezifische Variablen. Fügen Sie der Klasse PKW die Variablen p_dVerbrauch (Liter/100km), p dTankvolumen sowie p_dTankinhalt (Liter) hinzu. Ergänzen Sie die Klasse um einen entsprechenden Konstruktor, mit dem Sie zusätzlich zu den fahrzeugspezifischen Membervariablen auch Verbrauch und (optional, Default=55 l) Tankvolumen setzen können. Der Tankinhalt wird jeweils auf die Hälfte des Tankvolumens initialisiert. Nutzen Sie für die Einbeziehung der Konstruktoren der Basisklasse eine Initialisierungsliste.
   
   Des Weiteren schreiben Sie eine Funktion dTanken mit optionalem Parameter dMenge zum nachträglichen Betanken der PKWs. Wird kein Wert übergeben 154 Aufgabenblock 1: Grundlagen des Verkehrssystems (Defaultparameter) soll vollgetankt werden, ansonsten wird der gewünschte Wert getankt. Sie können die Konstante std::numeric `limits<double>::infinity()` aus dem Header`<limits>` als Default-Wert verwenden, die größer als alle (anderen) doubleWerte ist. Beachten Sie, dass maximal das Tankvolumen aufgefüllt werden kann. Geben Sie jeweils die tatsächlich getankte Menge zurück. Implementieren Sie die Funktion in der Klassenhierarchie so, dass sie für alle Fahrzeuge aufrufbar ist. Fahrräder und Fahrzeuge ohne Tank tanken bekanntlich nicht, d.h. die Funktion macht nichts und gibt immer 0 Liter zurück. 
   
   Bei jedem Simulationsschritt soll der Tankinhalt aktualisiert werden, bis der Tank leer ist. PKWs ohne Tankinhalt sollen liegenbleiben bis wieder nachgetankt wird. Danach sollen sie normal weiterfahren. Zur Vereinfachung soll die Reserve so groß sein, dass der PKW im letzten Schritt noch die komplette Teilstrecke fahren kann. Implementieren Sie dazu für PKW eine eigene Funktion vSimulieren(), die die zusätzliche Funktionalität von PKW implementiert. Für die allgemeine Simulation soll aber weiterhin Fahrzeug::vSimulieren() aufgerufen werden. Gesamtverbrauch (berechnet aus Gesamtstrecke) und aktueller Tankinhalt sollen außerdem noch in vAusgeben ergänzt werden. Beachte: Um Codeduplizierung in den abgeleiteten Klassen zu vermeiden, sollen die Daten, die zu Fahrzeuggehören, immer von Fahrzeug::vAusgeben ausgegeben werden. Rufen Sie diese Funktion also auch in den Ausgabefunktionen der abgeleiteten Klassen auf. Ergänzen Sie auch die Überschrift in Fahrzeug::vKopf() entsprechend.
1. Da Fahrradfahrer nicht immer mit maximaler Geschwindigkeit fahren können, soll eine Memberfunktion dGeschwindigkeit() implementiert werden. Sie wird in Fahrzeug als virtuell deklariert und für Fahrrad überschrieben. PKWs sollen immer mit ihrer vollen Geschwindigkeit fahren, Fahrradfahrer dagegen werden langsamer. Jeweils ausgehend von der gefahrenen Gesamtstrecke soll die Geschwindigkeit pro 20km um 10% abnehmen, minimal jedoch 12km/h betragen. Während eines Berechnungsschritts ist die Geschwindigkeit als konstant anzusehen. Beispiel: Nach 50 gefahrenen Kilometern beträgt die Geschwindigkeit im nächsten Zeittakt noch 81% der Maximalgeschwindigkeit, falls diese noch mehr als 12km/h beträgt. Stellen Sie nun Fahrzeug::vSimulieren() auf diese Funktionalität um (statt Maximalgeschwindigkeit). Andern Sie die Methode vAusgeben, sodass für jedes Fahrzeug zusätzlich zu den Fahrzeugdaten die aktuelle Geschwindigkeit ausgegeben wird.
2. Schreiben Sie eine neue Funktion vAufgabe_2(): Lesen Sie die Anzahl der zu erzeugenden PKWs und Fahrräder aus der Konsole ein, konstruieren Sie entsprechende Objekte der Klassen PKW und Fahrradund verwalten Sie sie in einem `vector<unique_ptr<Fahrzeug>>` Warum können/sollten Sie keine Fahrzeugobjekte speichern? Warum können Sie PKWs und Fahrräder in einem gemeinsamen Vektor speichern? Führen Sie für diese Objekte mehrere Simulationsschritte durch. Nach genau 3 Stunden tanken Sie die PKWs nochmals voll. Die Zeitabfrage dazu soll im Testprogramm erfolgen, nicht innerhalb von dTanken(). Testen Sie dies mit verschiedenen Zeittakten. Geben Sie die Ergebnisse (Daten aller Fahrzeuge) nach jedem Schritt aus.
   
   Beachte: Gleichheit von double-Werten kann immer nur gegen eine Toleranz ϵ getestet werden, da Fließkomma-Berechnungen nicht komplett genau sind. Berechnen Sie dazu z.B. den Absolutbetrag der Diﬀerenz bei Gleichheit oder reduzieren Sie eine der Seiten des Vergleichs um ϵ bei ≥oder ≤. Die Funktion für den Absolutbetrag `std::fabs()` finden Sie in der Bibliothek `<cmath>`. Beachten Sie dieses Rundungsproblem bei allen weiteren Vergleichen zwischen Fließkomma-Werten.
## 4.4 Ausgabe der Objekte (Operatoren überladen)
1. Am Ende dieser Aufgabe sollen Fahrzeuge mit dem Ausgabeoperator angezeigt werden können. Fahrzeug hat ja bereits eine Methode vAusgeben(). Diese Memberfunktion soll nun fahrzeugspezifische Daten auf dem übergebenen AusgabeStream ausgeben. Dazu ändern sie diese nun in eine virtuelle Methode vAusgeben(ostream&) const. Markieren Sie in allen Fahrzeug-Klassen die geerbte vAusgeben-Methode als override, falls noch nicht geschehen.
2. Nun wollen wir Fahrzeug mit operator<<ausgeben können. Dazu müssen Sie den Ausgabeoperator überladen. Hier zur Erinnerung nochmal die Deklaration des Ausgabeoperators für eine Klasse X:
   ostream& operator<<(ostream& o, const X& x);
   Rufen Sie im Ausgabeoperator die vAusgeben-Methode mit dem übergebenen ostream auf.
   Beachte:
   Überladen Sie den Operator außerhalb der Klasse. Warum? Kommen Sie mit einer einzigen Definition für alle von Fahrzeug abgeleiteten Klassen aus? Verwenden Sie bitte keine friend-Deklaration.
3. Testen Sie den Ausgabeoperator, indem Sie Fahrzeuge, PKWs und Fahrräder damit auf cout ausgeben: 
   Beispiel:
   std::cout << *aPKW << std::endl << *aFahrrad << std::endl;
   Verwenden Sie ab jetzt zur Ausgabe von Daten nur noch den <<-Operator.
4. Überladen Sie in der Klasse Fahrzeug den Vergleichsoperator operator<(). Dieser soll den Wert true liefern, falls die bisher zurückgelegte Gesamtstrecke vom aktuellen Objekt kleiner als die vom Vergleichsobjekt ist.
5. Verbieten Sie den Copy-Konstruktor, benutzen Sie hierzu delete. Überdenken Sie, wieso dies sinnvoll ist. Wo wird er implizit aufgerufen? Was bedeutet dies in diesem Szenario? Definieren Sie den Zuweisungsoperator (operator=()), so dass nur die Stammdaten (Daten die bei der Erstellung festgelegt werden) kopiert werden. Können Sie alle Daten kopieren? Was müssen Sie bei der ID beachten? Was würde passieren, wenn Sie keine eigene Definition des Operators erstellen würden? Was passiert, wenn Sie Elemente der Unterklasse zuweisen? Machen Sie sich den Unterschied zwischen Copy-Konstruktor und Zuweisungsoperator klar. Es geht hier nur um das prinzipielle Verständnis der Funktion des Zuweisungsoperators. Die genaue Implementierung des Zuweisungsoperators spielt für die weitere Aufgabe keine Rolle.
6. Testen Sie alle in dieser Aufgabe neu erstellten Operatoren in einer Funktion vAufgabe_3().